{
  "version": 3,
  "sources": ["../externals.ts", "../jstracetoix.ts"],
  "sourcesContent": ["// --------------------------------------------------------------------\n// Copyright (c) 2024 Alexandre Bento Freire. All rights reserved.\n// Licensed under the MIT license\n// --------------------------------------------------------------------\n// DO NOT EDIT THIS FILE\n\nlet _stream: NodeBrowserStream = console.debug;\n\nexport type NodeBrowserStream = typeof console.debug;\nexport const getMultithreading = () => false;\nexport const setMultithreading = (multithreading: boolean) => { };\nexport const getThreadId = (threadIdParam: number | undefined = undefined) => 0;\nexport const acquireLock = () => {};\nexport const releaseLock = () => {};\nexport const writeToStream = (output: string) => { _stream(output); }\nexport const setStream = (stream: NodeBrowserStream | undefined) => {\n    _stream = stream || _stream;\n};\n", "// --------------------------------------------------------------------\n// Copyright (c) 2024 Alexandre Bento Freire. All rights reserved.\n// Licensed under the MIT license\n// --------------------------------------------------------------------\n\nimport {\n    NodeBrowserStream, getMultithreading, getThreadId, setMultithreading,\n    acquireLock, releaseLock, setStream, writeToStream\n} from './externals';\n\n/**\n * Format Type -- Defines how result and input values will be formatted.\n *\n * @typedef {Object} Format\n * @property {string} result - The format of the result value to be displayed.\n *          Defaults to `'{name}: `{value}`'`.\n * @property {string} input - The format of the input value to be displayed.\n *          Defaults to `'{name}: `{value}`'`.\n * @property {string} thread - The format of the thread ID to be displayed.\n *          Defaults to `'{id}: '`.\n * @property {string} sep - The separator text between each input and the result.\n *          Defaults to `' | '`.\n * @property {boolean} new_line - If `true`, it will add a new line at the end of the output.\n */\nexport type Format = {\n    result: string,\n    input: string,\n    thread: string,\n    sep: string,\n    new_line: boolean\n};\n\n/**\n * AllowResult -- If it's a boolean it will allow or disallow capture or display result.\n *                Any other type, it will override the value being captured or displayed.\n*/\nexport type AllowResult = boolean | any;\nexport type AllowCallback = (data: Record<string, any>) => AllowResult;\nexport type EventCallback = (data: Record<string, any>) => boolean;\n\nexport const DEFAULT_FORMAT: Format = {\n    result: '{name}:`{value}`',\n    input: '{name}:`{value}`',\n    thread: '{id}: ',\n    sep: ' | ',\n    new_line: true\n};\n\nlet _format: Format = DEFAULT_FORMAT;\nlet _inputsPerThreads: Record<number, Record<string, any>[]> = {};\nlet _threadNames: Record<number, string> = {};\n\n/**\n * Initializes global settings of the tracing tool.\n *\n * @param {Object} params - Parameters for initialization.\n * @param {NodeBrowserStream} [params.stream=process.stdout] - The output stream to write\n *       the output lines.\n *       Default \"process.stdout\" for node or component and \"console.debug\" for browser.\n * @param {boolean} [params.multithreading=false] - If `true`, it prefixes the output with\n *       `thread_id:`.\n * @param {Format} [params.format=DEFAULT_FORMAT] - Format object defining the output format.\n *       Defaults to `DEFAULT_FORMAT`.\n */\nexport const init__ = ({\n    stream = undefined,\n    multithreading = false,\n    format = DEFAULT_FORMAT\n}: {\n    stream?: NodeBrowserStream,\n    multithreading?: boolean,\n    format?: Format\n} = {}): void => {\n\n    acquireLock();\n    setStream(stream);\n    setMultithreading(multithreading);\n    _format = format;\n    _inputsPerThreads = {};\n    _threadNames = {};\n    releaseLock();\n};\n\n/**\n * Assigns a name to a thread.\n *\n * If no **name** is provided, it generates a name based on the number of threads.\n *\n * If no threadIdParam is provided, it uses the current thread ID.\n *\n * @param {string} [name] - The name for the thread.\n *       Defaults to 't%d' where %d is the number of threads.\n * @param {number} [threadIdParam] - The ID of the thread. Defaults to the current thread ID.\n */\nexport const t__ = (\n    name: string | undefined = undefined,\n    threadIdParam: number | undefined = undefined\n): void => {\n\n    acquireLock();\n    _threadNames[getThreadId(threadIdParam)] = name || `t${Object.keys(_threadNames).length}`;\n    releaseLock();\n};\n\n/**\n * Captures the input value for the current thread.\n *\n * If no name is provided, it generates a default name.\n *\n * @param {any} value The input value to store.\n * @param {Object} params Optional parameters object\n * @param {string | ((index: number, allowIndex: number, value: any) => string) } params.name The\n *       name of the input.\n *       Defaults to 'i%d' where %d is the number of inputs for the thread.\n * @param {boolean | ((index: number, name: string, value: any) => AllowResult} params.allow A\n *       function or value to allow tracing the input. **allow** is called before **name**.\n *       If it returns True or False, it will allow or disallow respectively.\n *       If it returns not bool, then it will display the allow result instead of the input value.\n * @param {number} params.level The level number to be used when there is more than one **d__**\n *       within the same expression or function.\n *       Defaults to 0.\n *\n * @returns The input value\n *\n * @example\n * c__(x);\n *\n * c__(x, { name: \"var-name\" });\n * c__(x, { name: (index, allowIndex, value) => `${index}` });\n *\n * [1, 2, 3, 4, 5].map(i => c__(i, { allow: (index, name, value) => index > 2 }));\n * [10, 20, 30].map(x => c__(x, { allow: (index, name, value) => value === 20 }));\n *\n * const z = d__(() => c__(outside_1) + y * c__(outside_2) + d__(() => k * c__(inside(5),\n *   { level: 1 })));\n */\nexport const c__ = (\n    value: any,\n    params?: {\n        name?: string | ((index: number, allowIndex: number, value: any) => string);\n        allow?: boolean | ((index: number, name: string, value: any) => AllowResult);\n        level?: number;\n    }\n): any => {\n    const { name = undefined, allow = undefined, level = 0 } = params || {};\n    acquireLock();\n    const _threadId = getThreadId();\n    if (!_inputsPerThreads[_threadId]) {\n        _inputsPerThreads[_threadId] = [{ index__: 0, meta__: ['meta__', 'index__'] }];\n    }\n\n    while (_inputsPerThreads[_threadId].length <= level) {\n        _inputsPerThreads[_threadId].push({ index__: 0, meta__: ['meta__', 'index__'] });\n    }\n\n    const inputs = _inputsPerThreads[_threadId][level];\n    const index = inputs.index__;\n    const metaCount = inputs.meta__.length;\n\n    let displayName = typeof name === 'function' ? name(index, Object.keys(inputs).length -\n        metaCount, value) : name || `i${Object.keys(inputs).length - metaCount}`;\n    let displayValue = value;\n    let allowResult = allow;\n    try {\n        if (typeof allow === 'function') {\n            allowResult = allow(index, displayName, value);\n            if (typeof allowResult !== 'boolean') {\n                displayValue = allowResult;\n                allowResult = true;\n            }\n        }\n    } finally {\n        if (allowResult === undefined || allowResult) {\n            inputs[displayName] = displayValue;\n        }\n        inputs.index__ = index + 1;\n        releaseLock();\n    }\n    return value;\n};\n\n/**\n * Displays formatted result and inputs for the current thread using a given format.\n *\n * Optionally calls `allow`, `before`, and `after` functions with the data.\n *\n * `allow`, `before`, and `after` will receive a parameter `data` with the allowed inputs.\n * The following meta values will also be available:\n *\n * - `meta__`: List of meta keys including the name key.\n * - `thread_id__`: ID of the thread being executed.\n * - `allow_input_count__`: Total number of inputs that are allowed.\n * - `input_count__`: Total number of inputs being captured.\n * - `allow__`: If `false` it was allowed. Use this for the `after` callback.\n * - `output__`: Text passed to `before` without `new_line`.\n * - `name`: The `value` parameter.\n *\n * @param {any} value - The result to trace.\n * @param {Object} params - The named parameters.\n * @param {string} [params.name='_'] - The name of the function being traced.\n * @param {boolean | AllowCallback} [params.allow] - A function to call to allow tracing.\n *  If it returns `false`, tracing is skipped but `after` is still called.\n *  If it returns a non-boolean value, it will display the allow result instead of the value.\n * @param {EventCallback} [params.before] - A function to call before displaying the output.\n *  If it returns `false`, tracing is skipped.\n * @param {EventCallback} [params.after] - A function to call after displaying the output.\n *  `after` is always called even if not allowed.\n * @param {Record<string, any>} [params.inputs] - Dictionary of additional inputs.\n * @param {Format} [params.format] - Alternative output format.\n * @returns {any} The traced value.\n *\n * @example\n * d__(x);\n * d__(c__(x) + c__(y));\n *\n * d__(c__(x) + c__(y), { name: \"output\" });\n *\n * d__(c__(x) + c__(y), { allow: data => data.input_count__ === 2 });\n * d__(c__(x) + c__(y), { allow: data => data.i0 === 10.0 });\n * d__(c__(x, { allow: (index, name, value) => value > 10 }) + c__(y),\n *     { allow: data => data.allow_input_count__ === 2 });\n *\n * d__([c__(x) for x in ['10', '20']], { before: data => '10' in data.output__ });\n *\n * d__([c__(x) for x in ['1', '2']], {\n *     allow: data => data.allow_input_count__ === 2,\n *     after: data => call_after(data) if (data.allow__) else \"\"\n * });\n */\nexport const d__ = (\n    value: any,\n    params: {\n        name?: string,\n        allow?: boolean | AllowCallback,\n        before?: EventCallback,\n        after?: EventCallback,\n        inputs?: Record<string, any>,\n        format?: Format\n    } = {}\n): any => {\n\n    let {\n        name = '_',\n        allow = undefined,\n        before = undefined,\n        after = undefined,\n        inputs = undefined,\n        format = undefined\n    } = params || {};\n\n    acquireLock();\n    const _threadId = getThreadId();\n    const threadInputs = _inputsPerThreads[_threadId] || [{}];\n    const data = { ...threadInputs[threadInputs.length - 1], ...(inputs || {}) };\n\n    data.thread_id__ = _threadId;\n    data.input_count__ = data.index__ || 0;\n    data.allow__ = true;\n    data.meta__ = [...(data.meta__ || ['meta__']), 'allow__', 'allow_input_count__',\n        'input_count__', 'thread_id__', name];\n    data[name] = value;\n    delete data.index__;\n    data.meta__ = data.meta__.filter((item: string) => item !== 'index__');\n    data.allow_input_count__ = Object.keys(data).length - data.meta__.length + 1\n\n    try {\n        if (typeof allow === 'function') {\n            allow = allow(data);\n            if (typeof allow !== 'boolean') {\n                data[name] = allow;\n                allow = true;\n            }\n        }\n\n        if (allow !== false) {\n            format = format || _format;\n            let output = '';\n\n            if (getMultithreading() && format.thread) {\n                output += format.thread.replace('{id}', _threadNames[_threadId] || `${_threadId}`);\n            }\n\n            const replaceMacro = (_format: string, _name: string, _value: any) =>\n                _format.replace('{name}', _name).replace('{value}',\n                    typeof _value === 'object' ? JSON.stringify(_value) : _value);\n\n            if (format.input) {\n                for (const key in data) {\n                    if (!data.meta__.includes(key)) {\n                        output += replaceMacro(format.input, key, data[key]) + (format.sep || '');\n                    }\n                }\n            }\n\n            if (format.result) {\n                output += replaceMacro(format.result, name, data[name]);\n            }\n\n            data.meta__ += ['output__'];\n            data.output__ = output;\n            if (before === undefined || before(data)) {\n                writeToStream(data.output__ + (format.new_line ? '\\n' : ''));\n            }\n        } else {\n            data.allow__ = false;\n        }\n\n        after && after(data);\n    } finally {\n        if (_inputsPerThreads[_threadId]) {\n            _inputsPerThreads[_threadId].pop();\n            if (_inputsPerThreads[_threadId].length === 0) {\n                delete _inputsPerThreads[_threadId];\n            }\n        }\n        releaseLock();\n    }\n    return value;\n};\n"],
  "mappings": ";;;;;AAMA,IAAIA,EAA6B,QAAQ,MAG5BC,EAAoB,IAAM,GAC1BC,EAAqBC,GAA4B,CAAE,EACnDC,EAAc,CAACC,EAAoC,SAAc,EACjEC,EAAc,IAAM,CAAC,EACrBC,EAAc,IAAM,CAAC,EACrBC,EAAiBC,GAAmB,CAAET,EAAQS,CAAM,CAAG,EACvDC,EAAaC,GAA0C,CAChEX,EAAUW,GAAUX,CACxB,ECuBO,IAAMY,EAAyB,CAClC,OAAQ,mBACR,MAAO,mBACP,OAAQ,SACR,IAAK,MACL,SAAU,EACd,EAEIC,EAAkBD,EAClBE,EAA2D,CAAC,EAC5DC,EAAuC,CAAC,EAc/BC,EAAS,CAAC,CACnB,OAAAC,EAAS,OACT,eAAAC,EAAiB,GACjB,OAAAC,EAASP,CACb,EAII,CAAC,IAAY,CAEbQ,EAAY,EACZC,EAAUJ,CAAM,EAChBK,EAAkBJ,CAAc,EAChCL,EAAUM,EACVL,EAAoB,CAAC,EACrBC,EAAe,CAAC,EAChBQ,EAAY,CAChB,EAaaC,EAAM,CACfC,EAA2B,OAC3BC,EAAoC,SAC7B,CAEPN,EAAY,EACZL,EAAaY,EAAYD,CAAa,CAAC,EAAID,GAAQ,IAAI,OAAO,KAAKV,CAAY,EAAE,MAAM,GACvFQ,EAAY,CAChB,EAkCaK,EAAM,CACfC,EACAC,IAKM,CACN,GAAM,CAAE,KAAAL,EAAO,OAAW,MAAAM,EAAQ,OAAW,MAAAC,EAAQ,CAAE,EAAIF,GAAU,CAAC,EACtEV,EAAY,EACZ,IAAMa,EAAYN,EAAY,EAK9B,IAJKb,EAAkBmB,CAAS,IAC5BnB,EAAkBmB,CAAS,EAAI,CAAC,CAAE,QAAS,EAAG,OAAQ,CAAC,SAAU,SAAS,CAAE,CAAC,GAG1EnB,EAAkBmB,CAAS,EAAE,QAAUD,GAC1ClB,EAAkBmB,CAAS,EAAE,KAAK,CAAE,QAAS,EAAG,OAAQ,CAAC,SAAU,SAAS,CAAE,CAAC,EAGnF,IAAMC,EAASpB,EAAkBmB,CAAS,EAAED,CAAK,EAC3CG,EAAQD,EAAO,QACfE,EAAYF,EAAO,OAAO,OAE5BG,EAAc,OAAOZ,GAAS,WAAaA,EAAKU,EAAO,OAAO,KAAKD,CAAM,EAAE,OAC3EE,EAAWP,CAAK,EAAIJ,GAAQ,IAAI,OAAO,KAAKS,CAAM,EAAE,OAASE,CAAS,GACtEE,EAAeT,EACfU,EAAcR,EAClB,GAAI,CACI,OAAOA,GAAU,aACjBQ,EAAcR,EAAMI,EAAOE,EAAaR,CAAK,EACzC,OAAOU,GAAgB,YACvBD,EAAeC,EACfA,EAAc,IAG1B,QAAE,EACMA,IAAgB,QAAaA,KAC7BL,EAAOG,CAAW,EAAIC,GAE1BJ,EAAO,QAAUC,EAAQ,EACzBZ,EAAY,CAChB,CACA,OAAOM,CACX,EAkDaW,EAAM,CACfX,EACAC,EAOI,CAAC,IACC,CAEN,GAAI,CACA,KAAAL,EAAO,IACP,MAAAM,EAAQ,OACR,OAAAU,EAAS,OACT,MAAAC,EAAQ,OACR,OAAAR,EAAS,OACT,OAAAf,EAAS,MACb,EAAIW,GAAU,CAAC,EAEfV,EAAY,EACZ,IAAMa,EAAYN,EAAY,EACxBgB,EAAe7B,EAAkBmB,CAAS,GAAK,CAAC,CAAC,CAAC,EAClDW,EAAO,CAAE,GAAGD,EAAaA,EAAa,OAAS,CAAC,EAAG,GAAIT,GAAU,CAAC,CAAG,EAE3EU,EAAK,YAAcX,EACnBW,EAAK,cAAgBA,EAAK,SAAW,EACrCA,EAAK,QAAU,GACfA,EAAK,OAAS,CAAC,GAAIA,EAAK,QAAU,CAAC,QAAQ,EAAI,UAAW,sBACtD,gBAAiB,cAAenB,CAAI,EACxCmB,EAAKnB,CAAI,EAAII,EACb,OAAOe,EAAK,QACZA,EAAK,OAASA,EAAK,OAAO,OAAQC,GAAiBA,IAAS,SAAS,EACrED,EAAK,oBAAsB,OAAO,KAAKA,CAAI,EAAE,OAASA,EAAK,OAAO,OAAS,EAE3E,GAAI,CASA,GARI,OAAOb,GAAU,aACjBA,EAAQA,EAAMa,CAAI,EACd,OAAOb,GAAU,YACjBa,EAAKnB,CAAI,EAAIM,EACbA,EAAQ,KAIZA,IAAU,GAAO,CACjBZ,EAASA,GAAUN,EACnB,IAAIiC,EAAS,GAETC,EAAkB,GAAK5B,EAAO,SAC9B2B,GAAU3B,EAAO,OAAO,QAAQ,OAAQJ,EAAakB,CAAS,GAAK,GAAGA,CAAS,EAAE,GAGrF,IAAMe,EAAe,CAACnC,EAAiBoC,EAAeC,IAClDrC,EAAQ,QAAQ,SAAUoC,CAAK,EAAE,QAAQ,UACrC,OAAOC,GAAW,SAAW,KAAK,UAAUA,CAAM,EAAIA,CAAM,EAEpE,GAAI/B,EAAO,MACP,QAAWgC,KAAOP,EACTA,EAAK,OAAO,SAASO,CAAG,IACzBL,GAAUE,EAAa7B,EAAO,MAAOgC,EAAKP,EAAKO,CAAG,CAAC,GAAKhC,EAAO,KAAO,KAK9EA,EAAO,SACP2B,GAAUE,EAAa7B,EAAO,OAAQM,EAAMmB,EAAKnB,CAAI,CAAC,GAG1DmB,EAAK,QAAU,CAAC,UAAU,EAC1BA,EAAK,SAAWE,GACZL,IAAW,QAAaA,EAAOG,CAAI,IACnCQ,EAAcR,EAAK,UAAYzB,EAAO,SAAW;AAAA,EAAO,GAAG,CAEnE,MACIyB,EAAK,QAAU,GAGnBF,GAASA,EAAME,CAAI,CACvB,QAAE,CACM9B,EAAkBmB,CAAS,IAC3BnB,EAAkBmB,CAAS,EAAE,IAAI,EAC7BnB,EAAkBmB,CAAS,EAAE,SAAW,GACxC,OAAOnB,EAAkBmB,CAAS,GAG1CV,EAAY,CAChB,CACA,OAAOM,CACX",
  "names": ["_stream", "getMultithreading", "setMultithreading", "multithreading", "getThreadId", "threadIdParam", "acquireLock", "releaseLock", "writeToStream", "output", "setStream", "stream", "DEFAULT_FORMAT", "_format", "_inputsPerThreads", "_threadNames", "init__", "stream", "multithreading", "format", "acquireLock", "setStream", "setMultithreading", "releaseLock", "t__", "name", "threadIdParam", "getThreadId", "c__", "value", "params", "allow", "level", "_threadId", "inputs", "index", "metaCount", "displayName", "displayValue", "allowResult", "d__", "before", "after", "threadInputs", "data", "item", "output", "getMultithreading", "replaceMacro", "_name", "_value", "key", "writeToStream"]
}
