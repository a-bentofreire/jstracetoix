{
  "version": 3,
  "sources": ["../jstracetoix.ts"],
  "sourcesContent": ["// --------------------------------------------------------------------\n// Copyright (c) 2024 Alexandre Bento Freire. All rights reserved.\n// Licensed under the MIT license\n// --------------------------------------------------------------------\n\nimport { threadId } from 'worker_threads';\nimport { Writable } from 'stream';\n\n/**\n * Format Type -- Defines how result and input values will be formatted.\n *\n * @typedef {Object} Format\n * @property {string} result - The format of the result value to be displayed.\n *          Defaults to `'{name}: `{value}`'`.\n * @property {string} input - The format of the input value to be displayed.\n *          Defaults to `'{name}: `{value}`'`.\n * @property {string} thread - The format of the thread ID to be displayed.\n *          Defaults to `'{id}: '`.\n * @property {string} sep - The separator text between each input and the result.\n *          Defaults to `' | '`.\n * @property {boolean} new_line - If `true`, it will add a new line at the end of the output.\n */\nexport type Format = {\n    result: string,\n    input: string,\n    thread: string,\n    sep: string,\n    new_line: boolean\n};\n\n/**\n * AllowResult -- If it's a boolean it will allow or disallow capture or display result.\n *                Any other type, it will override the value being captured or displayed.\n*/\nexport type AllowResult = boolean | any;\nexport type AllowCallback = (data: Record<string, any>) => AllowResult;\nexport type EventCallback = (data: Record<string, any>) => boolean;\n/**\n * NodeBrowserStream -- \"Writeable\" stream for nodejs. Debug function for browser.\n *                      Default \"process.stdout\" for nodejs. \"console.debug\" for browser.\n*/\nexport type NodeBrowserStream = Writable | typeof console.debug;\n\nexport const DEFAULT_FORMAT: Format = {\n    result: '{name}:`{value}`',\n    input: '{name}:`{value}`',\n    thread: '{id}: ',\n    sep: ' | ',\n    new_line: true\n};\n\nlet _stream: NodeBrowserStream = IS_NODE ? process.stdout : console.debug;\nlet _multithreading = false;\nlet _format: Format = DEFAULT_FORMAT;\nlet _inputsPerThreads: Record<number, Record<string, any>[]> = {};\nlet _threadNames: Record<number, string> = {};\n\nlet _sharedLockBuffer = IS_NODE ? new SharedArrayBuffer(4) : undefined;\nlet _lockArray = IS_NODE ? new Int32Array(_sharedLockBuffer as SharedArrayBuffer) : undefined;\n\nconst acquireLock = () => {\n    if (IS_NODE && _multithreading) {\n        while (Atomics.compareExchange(_lockArray as Int32Array, 0, 0, 1) !== 0) { }\n    }\n};\n\nconst releaseLock = () => {\n    if (IS_NODE && _multithreading) {\n        Atomics.store(_lockArray as Int32Array, 0, 0);\n    }\n};\n\nconst getThreadId = (threadIdParam: number | undefined = undefined) => {\n    return IS_NODE ? (threadIdParam || threadId) : 0;\n};\n\n/**\n * Initializes global settings of the tracing tool.\n *\n * @param {Object} params - Parameters for initialization.\n * @param {NodeBrowserStream} [params.stream=process.stdout] - The output stream to write\n *       the output lines. Defaults to `process.stdout`.\n * @param {boolean} [params.multithreading=false] - If `true`, it prefixes the output with\n *       `thread_id:`.\n * @param {Format} [params.format=DEFAULT_FORMAT] - Format object defining the output format.\n *       Defaults to `DEFAULT_FORMAT`.\n */\nexport const init__ = ({\n    stream = _stream,\n    multithreading = false,\n    format = DEFAULT_FORMAT\n}: {\n    stream?: NodeBrowserStream,\n    multithreading?: boolean,\n    format?: Format\n} = {}): void => {\n\n    acquireLock();\n    _stream = stream;\n    _multithreading = IS_NODE ? multithreading : false;\n    _format = format;\n    _inputsPerThreads = {};\n    _threadNames = {};\n    releaseLock();\n};\n\n/**\n * Assigns a name to a thread.\n *\n * If no **name** is provided, it generates a name based on the number of threads.\n *\n * If no threadIdParam is provided, it uses the current thread ID.\n *\n * @param {string} [name] - The name for the thread.\n *       Defaults to 't%d' where %d is the number of threads.\n * @param {number} [threadIdParam] - The ID of the thread. Defaults to the current thread ID.\n */\nexport const t__ = (\n    name: string | undefined = undefined,\n    threadIdParam: number | undefined = undefined\n): void => {\n\n    acquireLock();\n    _threadNames[getThreadId(threadIdParam)] = name || `t${Object.keys(_threadNames).length}`;\n    releaseLock();\n};\n\n/**\n * Captures the input value for the current thread.\n *\n * If no name is provided, it generates a default name.\n *\n * @param {any} value The input value to store.\n * @param {Object} params Optional parameters object\n * @param {string | ((index: number, allowIndex: number, value: any) => string) } params.name The\n *       name of the input.\n *       Defaults to 'i%d' where %d is the number of inputs for the thread.\n * @param {boolean | ((index: number, name: string, value: any) => AllowResult} params.allow A\n *       function or value to allow tracing the input. **allow** is called before **name**.\n *       If it returns True or False, it will allow or disallow respectively.\n *       If it returns not bool, then it will display the allow result instead of the input value.\n * @param {number} params.level The level number to be used when there is more than one **d__**\n *       within the same expression or function.\n *       Defaults to 0.\n *\n * @returns The input value\n *\n * @example\n * c__(x);\n *\n * c__(x, { name: \"var-name\" });\n * c__(x, { name: (index, allowIndex, value) => `${index}` });\n *\n * [1, 2, 3, 4, 5].map(i => c__(i, { allow: (index, name, value) => index > 2 }));\n * [10, 20, 30].map(x => c__(x, { allow: (index, name, value) => value === 20 }));\n *\n * const z = d__(() => c__(outside_1) + y * c__(outside_2) + d__(() => k * c__(inside(5), \n *   { level: 1 })));\n */\nexport const c__ = (\n    value: any,\n    params?: {\n        name?: string | ((index: number, allowIndex: number, value: any) => string);\n        allow?: boolean | ((index: number, name: string, value: any) => AllowResult);\n        level?: number;\n    }\n): any => {\n    const { name = undefined, allow = undefined, level = 0 } = params || {};\n    acquireLock();\n    const _threadId = getThreadId();\n    if (!_inputsPerThreads[_threadId]) {\n        _inputsPerThreads[_threadId] = [{ index__: 0, meta__: ['meta__', 'index__'] }];\n    }\n\n    while (_inputsPerThreads[_threadId].length <= level) {\n        _inputsPerThreads[_threadId].push({ index__: 0, meta__: ['meta__', 'index__'] });\n    }\n\n    const inputs = _inputsPerThreads[_threadId][level];\n    const index = inputs.index__;\n    const metaCount = inputs.meta__.length;\n\n    let displayName = typeof name === 'function' ? name(index, Object.keys(inputs).length -\n        metaCount, value) : name || `i${Object.keys(inputs).length - metaCount}`;\n    let displayValue = value;\n    let allowResult = allow;\n    try {\n        if (typeof allow === 'function') {\n            allowResult = allow(index, displayName, value);\n            if (typeof allowResult !== 'boolean') {\n                displayValue = allowResult;\n                allowResult = true;\n            }\n        }\n    } finally {\n        if (allowResult === undefined || allowResult) {\n            inputs[displayName] = displayValue;\n        }\n        inputs.index__ = index + 1;\n        releaseLock();\n    }\n    return value;\n};\n\n/**\n * Displays formatted result and inputs for the current thread using a given format.\n *\n * Optionally calls `allow`, `before`, and `after` functions with the data.\n *\n * `allow`, `before`, and `after` will receive a parameter `data` with the allowed inputs.\n * The following meta values will also be available:\n *\n * - `meta__`: List of meta keys including the name key.\n * - `thread_id__`: ID of the thread being executed.\n * - `allow_input_count__`: Total number of inputs that are allowed.\n * - `input_count__`: Total number of inputs being captured.\n * - `allow__`: If `false` it was allowed. Use this for the `after` callback.\n * - `output__`: Text passed to `before` without `new_line`.\n * - `name`: The `value` parameter.\n *\n * @param {any} value - The result to trace.\n * @param {Object} params - The named parameters.\n * @param {string} [params.name='_'] - The name of the function being traced.\n * @param {boolean | AllowCallback} [params.allow] - A function to call to allow tracing.\n *  If it returns `false`, tracing is skipped but `after` is still called.\n *  If it returns a non-boolean value, it will display the allow result instead of the value.\n * @param {EventCallback} [params.before] - A function to call before displaying the output.\n *  If it returns `false`, tracing is skipped.\n * @param {EventCallback} [params.after] - A function to call after displaying the output.\n *  `after` is always called even if not allowed.\n * @param {Record<string, any>} [params.inputs] - Dictionary of additional inputs.\n * @param {Format} [params.format] - Alternative output format.\n * @returns {any} The traced value.\n *\n * @example\n * d__(x);\n * d__(c__(x) + c__(y));\n *\n * d__(c__(x) + c__(y), { name: \"output\" });\n *\n * d__(c__(x) + c__(y), { allow: data => data.input_count__ === 2 });\n * d__(c__(x) + c__(y), { allow: data => data.i0 === 10.0 });\n * d__(c__(x, { allow: (index, name, value) => value > 10 }) + c__(y),\n *     { allow: data => data.allow_input_count__ === 2 });\n *\n * d__([c__(x) for x in ['10', '20']], { before: data => '10' in data.output__ });\n *\n * d__([c__(x) for x in ['1', '2']], {\n *     allow: data => data.allow_input_count__ === 2,\n *     after: data => call_after(data) if (data.allow__) else \"\"\n * });\n */\nexport const d__ = (\n    value: any,\n    params: {\n        name?: string,\n        allow?: boolean | AllowCallback,\n        before?: EventCallback,\n        after?: EventCallback,\n        inputs?: Record<string, any>,\n        format?: Format\n    } = {}\n): any => {\n\n    let {\n        name = '_',\n        allow = undefined,\n        before = undefined,\n        after = undefined,\n        inputs = undefined,\n        format = undefined\n    } = params || {};\n\n    acquireLock();\n    const _threadId = getThreadId();\n    const threadInputs = _inputsPerThreads[_threadId] || [{}];\n    const data = { ...threadInputs[threadInputs.length - 1], ...(inputs || {}) };\n\n    data.thread_id__ = _threadId;\n    data.input_count__ = data.index__ || 0;\n    data.allow__ = true;\n    data.meta__ = [...(data.meta__ || ['meta__']), 'allow__', 'allow_input_count__',\n        'input_count__', 'thread_id__', name];\n    data[name] = value;\n    delete data.index__;\n    data.meta__ = data.meta__.filter((item: string) => item !== 'index__');\n    data.allow_input_count__ = Object.keys(data).length - data.meta__.length + 1\n\n    try {\n        if (typeof allow === 'function') {\n            allow = allow(data);\n            if (typeof allow !== 'boolean') {\n                data[name] = allow;\n                allow = true;\n            }\n        }\n\n        if (allow !== false) {\n            format = format || _format;\n            let output = '';\n\n            if (_multithreading && format.thread) {\n                output += format.thread.replace('{id}', _threadNames[_threadId] || `${_threadId}`);\n            }\n\n            const replaceMacro = (_format: string, _name: string, _value: any) =>\n                _format.replace('{name}', _name).replace('{value}',\n                    typeof _value === 'object' ? JSON.stringify(_value) : _value);\n\n            for (const key in data) {\n                if (!data.meta__.includes(key)) {\n                    output += replaceMacro(format.input, key, data[key]) + format.sep;\n                }\n            }\n\n            if (format.result) {\n                output += replaceMacro(format.result, name, data[name]);\n            }\n\n            data.meta__ += ['output__'];\n            data.output__ = output;\n            if (before === undefined || before(data)) {\n                output = data.output__ + (format.new_line ? '\\n' : '');\n                if (IS_NODE) {\n                    (_stream as Writable).write(output);\n                } else {\n                    (_stream as typeof console.debug)(output);\n                }\n            }\n        } else {\n            data.allow__ = false;\n        }\n\n        after && after(data);\n    } finally {\n        if (_inputsPerThreads[_threadId]) {\n            _inputsPerThreads[_threadId].pop();\n            if (_inputsPerThreads[_threadId].length === 0) {\n                delete _inputsPerThreads[_threadId];\n            }\n        }\n        releaseLock();\n    }\n    return value;\n};\n"],
  "mappings": "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",
  "names": ["threadId", "_stream", "_multithreading", "_format", "_inputsPerThreads", "_threadNames", "_sharedLockBuffer", "_lockArray", "acquireLock", "releaseLock", "getThreadId", "threadIdParam", "stream", "multithreading", "format", "name", "value", "params", "allow", "level", "_threadId", "inputs", "index", "metaCount", "displayName", "displayValue", "allowResult", "before", "after", "threadInputs", "data", "item", "output", "replaceMacro", "_name", "_value", "key"]
}
