{
  "version": 3,
  "sources": ["../jstracetoix.ts"],
  "sourcesContent": ["// --------------------------------------------------------------------\n// Copyright (c) 2024 Alexandre Bento Freire. All rights reserved.\n// Licensed under the MIT license\n// --------------------------------------------------------------------\n\nimport { threadId } from 'worker_threads';\nimport { Writable } from 'stream';\n\n/**\n * Format Type -- Defines how result and input values will be formatted.\n *\n * @typedef {Object} Format\n * @property {string} result - The format of the result value to be displayed. Defaults to `'{name}: `{value}`'`.\n * @property {string} input - The format of the input value to be displayed. Defaults to `'{name}: `{value}`'`.\n * @property {string} thread - The format of the thread ID to be displayed. Defaults to `'{id}: '`.\n * @property {string} sep - The separator text between each input and the result. Defaults to `' | '`.\n * @property {boolean} new_line - If `true`, it will add a new line at the end of the output.\n */\nexport type Format = {\n    result: string,\n    input: string,\n    thread: string,\n    sep: string,\n    new_line: boolean\n};\n\ntype AllowResult = boolean | any;\ntype AllowCallback = (data: Record<string, any>) => AllowResult;\ntype EventCallback = (data: Record<string, any>) => boolean;\ntype NodeBrowserStream = Writable | typeof console.debug;\n\nexport const DEFAULT_FORMAT: Format = {\n    result: '{name}:`{value}`',\n    input: '{name}:`{value}`',\n    thread: '{id}: ',\n    sep: ' | ',\n    new_line: true\n};\n\nlet _stream: NodeBrowserStream = IS_NODE ? process.stdout : console.debug;\nlet _multithreading = false;\nlet _format: Format = DEFAULT_FORMAT;\nlet _inputsPerThreads: Record<number, Record<string, any>[]> = {};\nlet _threadNames: Record<number, string> = {};\n\nlet _sharedLockBuffer = IS_NODE ? new SharedArrayBuffer(4) : undefined;\nlet _lockArray = IS_NODE ? new Int32Array(_sharedLockBuffer as SharedArrayBuffer) : undefined;\n\nconst acquireLock = () => {\n    if (IS_NODE && _multithreading) {\n        while (Atomics.compareExchange(_lockArray as Int32Array, 0, 0, 1) !== 0) { }\n    }\n};\n\nconst releaseLock = () => {\n    if (IS_NODE && _multithreading) {\n        Atomics.store(_lockArray as Int32Array, 0, 0);\n    }\n};\n\nconst getThreadId = (threadIdParam: number | undefined = undefined) => {\n    return IS_NODE ? (threadIdParam || threadId) : 0;\n};\n\n/**\n * Initializes global settings of the tracing tool.\n *\n * @param {Object} params - Parameters for initialization.\n * @param {NodeBrowserStream} [params.stream=process.stdout] - The output stream to write the output lines.\n *      Defaults to `process.stdout`.\n * @param {boolean} [params.multithreading=false] - If `true`, it prefixes the output with `thread_id:`.\n * @param {Format} [params.format=DEFAULT_FORMAT] - Format object defining the output format. Defaults to `DEFAULT_FORMAT`.\n */\nexport const init__ = ({\n    stream = _stream,\n    multithreading = false,\n    format = DEFAULT_FORMAT\n}: {\n    stream?: NodeBrowserStream,\n    multithreading?: boolean,\n    format?: Format\n} = {}): void => {\n\n    acquireLock();\n    _stream = stream;\n    _multithreading = IS_NODE ? multithreading : false;\n    _format = format;\n    _inputsPerThreads = {};\n    _threadNames = {};\n    releaseLock();\n};\n\n/**\n * Assigns a name to a thread.\n *\n * If no **name** is provided, it generates a name based on the number of threads.\n *\n * If no threadIdParam is provided, it uses the current thread ID.\n *\n * @param {string} [name] - The name for the thread. Defaults to 't%d' where %d is the number of threads.\n * @param {number} [threadIdParam] - The ID of the thread. Defaults to the current thread ID.\n */\nexport const t__ = (\n    name: string | undefined = undefined,\n    threadIdParam: number | undefined = undefined\n): void => {\n\n    acquireLock();\n    _threadNames[getThreadId(threadIdParam)] = name || `t${Object.keys(_threadNames).length}`;\n    releaseLock();\n};\n\n/**\n * Captures the input value for the current thread.\n *\n * If no name is provided, it generates a default name.\n *\n * @param {any} value The input value to store.\n * @param {Object} params Optional parameters object\n * @param {string | ((index: number, allowIndex: number, value: any) => string) } params.name The\n *                     name of the input.\n *                     Defaults to 'i%d' where %d is the number of inputs for the thread.\n * @param {boolean | ((index: number, name: string, value: any) => AllowResult} params.allow A function\n *                     or value to allow tracing the input. **allow** is called before **name**.\n *                     If it returns True or False, it will allow or disallow respectively.\n *                     If it returns not bool, then it will display the allow result instead of the input value.\n * @param {number} params.level The level number to be used when there is more than one **d__** within the same\n *                     expression or function.\n *                     Defaults to 0.\n *\n * @returns The input value\n *\n * @example\n * c__(x);\n *\n * c__(x, { name: \"var-name\" });\n * c__(x, { name: (index, allowIndex, value) => `${index}` });\n *\n * [1, 2, 3, 4, 5].map(i => c__(i, { allow: (index, name, value) => index > 2 }));\n * [10, 20, 30].map(x => c__(x, { allow: (index, name, value) => value === 20 }));\n *\n * const z = d__(() => c__(outside_1) + y * c__(outside_2) + d__(() => k * c__(inside(5), { level: 1 })));\n */\nexport const c__ = (\n    value: any,\n    params?: {\n        name?: string | ((index: number, allowIndex: number, value: any) => string);\n        allow?: boolean | ((index: number, name: string, value: any) => AllowResult);\n        level?: number;\n    }\n): any => {\n    const { name = undefined, allow = undefined, level = 0 } = params || {};\n    acquireLock();\n    const _threadId = getThreadId();\n    if (!_inputsPerThreads[_threadId]) {\n        _inputsPerThreads[_threadId] = [{ index__: 0, meta__: ['meta__', 'index__'] }];\n    }\n\n    while (_inputsPerThreads[_threadId].length <= level) {\n        _inputsPerThreads[_threadId].push({ index__: 0, meta__: ['meta__', 'index__'] });\n    }\n\n    const inputs = _inputsPerThreads[_threadId][level];\n    const index = inputs.index__;\n    const metaCount = inputs.meta__.length;\n\n    let displayName = typeof name === 'function' ? name(index, Object.keys(inputs).length -\n        metaCount, value) : name || `i${Object.keys(inputs).length - metaCount}`;\n    let displayValue = value;\n\n    let allowResult = allow;\n    if (typeof allow === 'function') {\n        allowResult = allow(index, displayName, value);\n        if (typeof allowResult !== 'boolean') {\n            displayValue = allowResult;\n            allowResult = true;\n        }\n    }\n\n    if (allowResult === undefined || allowResult) {\n        inputs[displayName] = displayValue;\n    }\n    inputs.index__ = index + 1;\n    releaseLock();\n    return value;\n};\n\n/**\n * Displays formatted result and inputs for the current thread using a given format.\n *\n * Optionally calls `allow`, `before`, and `after` functions with the data.\n *\n * `allow`, `before`, and `after` will receive a parameter `data` with the allowed inputs.\n * The following meta values will also be available:\n *\n * - `meta__`: List of meta keys including the name key.\n * - `thread_id__`: ID of the thread being executed.\n * - `allow_input_count__`: Total number of inputs that are allowed.\n * - `input_count__`: Total number of inputs being captured.\n * - `allow__`: If `false` it was allowed. Use this for the `after` callback.\n * - `output__`: Text passed to `before` without `new_line`.\n * - `name`: The `value` parameter.\n *\n * @param {any} value - The result to trace.\n * @param {Object} params - The named parameters.\n * @param {string} [params.name='_'] - The name of the function being traced.\n * @param {boolean | AllowCallback} [params.allow] - A function to call to allow tracing.\n *  If it returns `false`, tracing is skipped but `after` is still called.\n *  If it returns a non-boolean value, it will display the allow result instead of the value.\n * @param {EventCallback} [params.before] - A function to call before displaying the output.\n *  If it returns `false`, tracing is skipped.\n * @param {EventCallback} [params.after] - A function to call after displaying the output.\n *  `after` is always called even if not allowed.\n * @param {Record<string, any>} [params.inputs] - Dictionary of additional inputs.\n * @param {Format} [params.format] - Alternative output format.\n * @returns {any} The traced value.\n *\n * @example\n * d__(x);\n * d__(c__(x) + c__(y));\n *\n * d__(c__(x) + c__(y), { name: \"output\" });\n *\n * d__(c__(x) + c__(y), { allow: data => data.input_count__ === 2 });\n * d__(c__(x) + c__(y), { allow: data => data.i0 === 10.0 });\n * d__(c__(x, { allow: (index, name, value) => value > 10 }) + c__(y),\n *     { allow: data => data.allow_input_count__ === 2 });\n *\n * d__([c__(x) for x in ['10', '20']], { before: data => '10' in data.output__ });\n *\n * d__([c__(x) for x in ['1', '2']], {\n *     allow: data => data.allow_input_count__ === 2,\n *     after: data => call_after(data) if (data.allow__) else \"\"\n * });\n */\nexport const d__ = (\n    value: any,\n    params: {\n        name?: string,\n        allow?: boolean | AllowCallback,\n        before?: EventCallback,\n        after?: EventCallback,\n        inputs?: Record<string, any>,\n        format?: Format\n    } = {}\n): any => {\n\n    let {\n        name = '_',\n        allow = undefined,\n        before = undefined,\n        after = undefined,\n        inputs = undefined,\n        format = undefined\n    } = params || {};\n\n    acquireLock();\n    const _threadId = getThreadId();\n    const threadInputs = _inputsPerThreads[_threadId] || [{}];\n    const data = { ...threadInputs[threadInputs.length - 1], ...(inputs || {}) };\n\n    data.thread_id__ = _threadId;\n    data.input_count__ = data.index__ || 0;\n    data.allow__ = true;\n    data.meta__ = [...(data.meta__ || ['meta__']), 'allow__', 'allow_input_count__',\n        'input_count__', 'thread_id__', name];\n    data[name] = value;\n    delete data.index__;\n    data.meta__ = data.meta__.filter((item: string) => item !== 'index__');\n    data.allow_input_count__ = Object.keys(data).length - data.meta__.length + 1\n\n    if (typeof allow === 'function') {\n        allow = allow(data);\n        if (typeof allow !== 'boolean') {\n            data[name] = allow;\n            allow = true;\n        }\n    }\n\n    if (allow !== false) {\n        format = format || _format;\n        let output = '';\n\n        if (_multithreading && format.thread) {\n            output += format.thread.replace('{id}', _threadNames[_threadId] || `${_threadId}`);\n        }\n\n        const replaceMacro = (_format: string, _name: string, _value: any) =>\n            _format.replace('{name}', _name)\n                .replace('{value}', typeof _value === 'object' ? JSON.stringify(_value) : _value);\n\n        for (const key in data) {\n            if (!data.meta__.includes(key)) {\n                output += replaceMacro(format.input, key, data[key]) + format.sep;\n            }\n        }\n\n        if (format.result) {\n            output += replaceMacro(format.result, name, data[name]);\n        }\n\n        data.meta__ += ['output__'];\n        data.output__ = output;\n        if (before === undefined || before(data)) {\n            output = data.output__ + (format.new_line ? '\\n' : '');\n            if (IS_NODE) {\n                (_stream as Writable).write(output);\n            } else {\n                (_stream as typeof console.debug)(output);\n            }\n        }\n    } else {\n        data.allow__ = false;\n    }\n\n    after && after(data);\n\n    if (_inputsPerThreads[_threadId]) {\n        _inputsPerThreads[_threadId].pop();\n        if (_inputsPerThreads[_threadId].length === 0) {\n            delete _inputsPerThreads[_threadId];\n        }\n    }\n    releaseLock();\n    return value;\n};\n"],
  "mappings": ";;;;++BAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,oBAAAE,EAAA,QAAAC,EAAA,QAAAC,EAAA,WAAAC,EAAA,QAAAC,IAKA,IAAAC,EAAyB,oBA0BlB,IAAMC,EAAyB,CAClC,OAAQ,mBACR,MAAO,mBACP,OAAQ,SACR,IAAK,MACL,SAAU,EACd,EAEIC,EAAwD,QAAQ,MAChEC,EAAkB,GAClBC,EAAkBH,EAClBI,EAA2D,CAAC,EAC5DC,EAAuC,CAAC,EAK5C,IAAMC,EAAc,IAAM,CAI1B,EAEMC,EAAc,IAAM,CAI1B,EAEMC,EAAc,CAACC,EAAoC,SACN,EAYtCC,EAAS,CAAC,CACnB,OAAAC,EAASC,EACT,eAAAC,EAAiB,GACjB,OAAAC,EAASC,CACb,EAII,CAAC,IAAY,CAEbT,EAAY,EACZM,EAAUD,EACVK,EAA6C,GAC7CC,EAAUH,EACVI,EAAoB,CAAC,EACrBC,EAAe,CAAC,EAChBZ,EAAY,CAChB,EAYaa,EAAM,CACfC,EAA2B,OAC3BZ,EAAoC,SAC7B,CAEPH,EAAY,EACZa,EAAaX,EAAYC,CAAa,CAAC,EAAIY,GAAQ,IAAI,OAAO,KAAKF,CAAY,EAAE,MAAM,GACvFZ,EAAY,CAChB,EAiCae,EAAM,CACfC,EACAC,IAKM,CACN,GAAM,CAAE,KAAAH,EAAO,OAAW,MAAAI,EAAQ,OAAW,MAAAC,EAAQ,CAAE,EAAIF,GAAU,CAAC,EACtElB,EAAY,EACZ,IAAMqB,EAAYnB,EAAY,EAK9B,IAJKU,EAAkBS,CAAS,IAC5BT,EAAkBS,CAAS,EAAI,CAAC,CAAE,QAAS,EAAG,OAAQ,CAAC,SAAU,SAAS,CAAE,CAAC,GAG1ET,EAAkBS,CAAS,EAAE,QAAUD,GAC1CR,EAAkBS,CAAS,EAAE,KAAK,CAAE,QAAS,EAAG,OAAQ,CAAC,SAAU,SAAS,CAAE,CAAC,EAGnF,IAAMC,EAASV,EAAkBS,CAAS,EAAED,CAAK,EAC3CG,EAAQD,EAAO,QACfE,EAAYF,EAAO,OAAO,OAE5BG,EAAc,OAAOV,GAAS,WAAaA,EAAKQ,EAAO,OAAO,KAAKD,CAAM,EAAE,OAC3EE,EAAWP,CAAK,EAAIF,GAAQ,IAAI,OAAO,KAAKO,CAAM,EAAE,OAASE,CAAS,GACtEE,EAAeT,EAEfU,EAAcR,EAClB,OAAI,OAAOA,GAAU,aACjBQ,EAAcR,EAAMI,EAAOE,EAAaR,CAAK,EACzC,OAAOU,GAAgB,YACvBD,EAAeC,EACfA,EAAc,MAIlBA,IAAgB,QAAaA,KAC7BL,EAAOG,CAAW,EAAIC,GAE1BJ,EAAO,QAAUC,EAAQ,EACzBtB,EAAY,EACLgB,CACX,EAkDaW,EAAM,CACfX,EACAC,EAOI,CAAC,IACC,CAEN,GAAI,CACA,KAAAH,EAAO,IACP,MAAAI,EAAQ,OACR,OAAAU,EAAS,OACT,MAAAC,EAAQ,OACR,OAAAR,EAAS,OACT,OAAAd,EAAS,MACb,EAAIU,GAAU,CAAC,EAEflB,EAAY,EACZ,IAAMqB,EAAYnB,EAAY,EACxB6B,EAAenB,EAAkBS,CAAS,GAAK,CAAC,CAAC,CAAC,EAClDW,EAAOC,IAAA,GAAKF,EAAaA,EAAa,OAAS,CAAC,GAAOT,GAAU,CAAC,GAoBxE,GAlBAU,EAAK,YAAcX,EACnBW,EAAK,cAAgBA,EAAK,SAAW,EACrCA,EAAK,QAAU,GACfA,EAAK,OAAS,CAAC,GAAIA,EAAK,QAAU,CAAC,QAAQ,EAAI,UAAW,sBACtD,gBAAiB,cAAejB,CAAI,EACxCiB,EAAKjB,CAAI,EAAIE,EACb,OAAOe,EAAK,QACZA,EAAK,OAASA,EAAK,OAAO,OAAQE,GAAiBA,IAAS,SAAS,EACrEF,EAAK,oBAAsB,OAAO,KAAKA,CAAI,EAAE,OAASA,EAAK,OAAO,OAAS,EAEvE,OAAOb,GAAU,aACjBA,EAAQA,EAAMa,CAAI,EACd,OAAOb,GAAU,YACjBa,EAAKjB,CAAI,EAAII,EACbA,EAAQ,KAIZA,IAAU,GAAO,CACjBX,EAASA,GAAUG,EACnB,IAAIwB,EAAS,GAETzB,GAAmBF,EAAO,SAC1B2B,GAAU3B,EAAO,OAAO,QAAQ,OAAQK,EAAaQ,CAAS,GAAK,GAAGA,CAAS,EAAE,GAGrF,IAAMe,EAAe,CAACzB,EAAiB0B,EAAeC,IAClD3B,EAAQ,QAAQ,SAAU0B,CAAK,EAC1B,QAAQ,UAAW,OAAOC,GAAW,SAAW,KAAK,UAAUA,CAAM,EAAIA,CAAM,EAExF,QAAWC,KAAOP,EACTA,EAAK,OAAO,SAASO,CAAG,IACzBJ,GAAUC,EAAa5B,EAAO,MAAO+B,EAAKP,EAAKO,CAAG,CAAC,EAAI/B,EAAO,KAIlEA,EAAO,SACP2B,GAAUC,EAAa5B,EAAO,OAAQO,EAAMiB,EAAKjB,CAAI,CAAC,GAG1DiB,EAAK,QAAU,CAAC,UAAU,EAC1BA,EAAK,SAAWG,GACZN,IAAW,QAAaA,EAAOG,CAAI,KACnCG,EAASH,EAAK,UAAYxB,EAAO,SAAW;AAAA,EAAO,IAI9CF,EAAiC6B,CAAM,EAGpD,MACIH,EAAK,QAAU,GAGnB,OAAAF,GAASA,EAAME,CAAI,EAEfpB,EAAkBS,CAAS,IAC3BT,EAAkBS,CAAS,EAAE,IAAI,EAC7BT,EAAkBS,CAAS,EAAE,SAAW,GACxC,OAAOT,EAAkBS,CAAS,GAG1CpB,EAAY,EACLgB,CACX",
  "names": ["jstracetoix_exports", "__export", "DEFAULT_FORMAT", "c__", "d__", "init__", "t__", "import_worker_threads", "DEFAULT_FORMAT", "_stream", "_multithreading", "_format", "_inputsPerThreads", "_threadNames", "acquireLock", "releaseLock", "getThreadId", "threadIdParam", "init__", "stream", "_stream", "multithreading", "format", "DEFAULT_FORMAT", "_multithreading", "_format", "_inputsPerThreads", "_threadNames", "t__", "name", "c__", "value", "params", "allow", "level", "_threadId", "inputs", "index", "metaCount", "displayName", "displayValue", "allowResult", "d__", "before", "after", "threadInputs", "data", "__spreadValues", "item", "output", "replaceMacro", "_name", "_value", "key"]
}
